#!/usr/bin/env python3
import sys
import time
import random
import hashlib

# Having a non-weak seed when generating "random" numbers is super important! Can you figure out what is wrong with
# this PRNG implementation?

# seed.py is the Python script used to generate the flag for this challenge. log.txt is the output from the script when
# the flag was generated.

# What is the flag?

# ----------------------------------------------------------------------------------------------------------------------

# From the log we are given a set of random numbers generated by the script.
# We have to find the (time dependent) seeds which correspond to the random numbers in order to recreate the flag
random_vals = [0.3322089622063289, 0.10859805708337256, 0.39751456956943265, 0.6194981263678604, 0.32054505821893853,
               0.2674908181379442, 0.5379388350878211, 0.7799698997586163, 0.6893538761284775, 0.7171513961367021,
               0.29362186264112344, 0.06571100672753238, 0.9607588522085679, 0.33534977507836194, 0.07384192274198853,
               0.1448081453121044]

# My brute-force solution is probably not the most elegant/intended way but it works. TODO: Check writeups with alternative solutions

# Start at the current time and check the random numbers generated with the seeds at that respective time
cur_time = round(time.time())
# To speed up the script:
cur_time = 1634187271
for t in range(cur_time, 0, -1):
    random.seed(t, version=2)
    x = random.random()
    if x == 0.3322089622063289:
       print("Found starting seed candidate: ", t)
       break
    else:
       continue

# Use the seed that we found and check if it matches with the sequence we know (pick 50 as the function could have different delays e.g. called every 2 seconds)
# Manually analyse the randomly generated numbers and see that they match exactly our result
brute_force_seed = 1634187271
for i in range(1, 50):
    random.seed(brute_force_seed + i, version=2)
    x = random.random()
    print(x)

# We see that the random numbers perfectly match the sequence of the log file
# Consequently, if we set the seed of the original code to 1634187271 + len(random_vals), then we should get the correct flag

def seed():
    return round(time.time())

def hash(text):
    return hashlib.sha256(str(text).encode()).hexdigest()

times = [int(time.time()) - x for x in range(0, 60)]
def main():
    while True:
        #s = seed()
        s = brute_force_seed + len(random_vals)
        random.seed(s, version=2)

        x = random.random()

        flag = hash(x)
        if 'b9ff3ebf' in flag:
            print("dam{{{}}}".format(flag))
            with open("./flag", "w") as f:
                f.write(f"dam{{{flag}}}")
            f.close()
            break

        print(f"Incorrect: {x}")
    print("Good job <3")

if __name__ == "__main__":
   sys.exit(main())


